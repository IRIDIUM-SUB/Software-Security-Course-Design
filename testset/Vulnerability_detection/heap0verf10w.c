#include<stdio.h>
#include<string.h>

#define F_PATH "C:\\Users\\Administrator\\Desktop\\C\\data.txt"
#define ADDITION 10 //字符串添加多余空间防止溢出 

typedef struct{
	char value[80 + ADDITION];
}late;	// 一行模板 

typedef struct{
	char key[100 + ADDITION];
	char value[100 + ADDITION];
}variable;	// 一个变量 

void func()
{
    color=malloc(10);//使用内存分配函数在堆中
    gets(color);//著名的缓冲区溢出函数
    printf("your favorite color is %s/n",color);
}
int main()
{
	int m, n;
	late str[100 + ADDITION];
	variable var[100 + ADDITION];
	char ch;
	
	scanf("%d %d", &m, &n);
	
/*	while( (ch=getchar()) != '\n' )
		continue;*/
	ch = getchar();	// 必须加这个，因为%[]读取时会把上一个\n给读取到进去然后跳过直接空字符串。不用ch = getchar();就得在上一个scanf（）改成 scanf("%d %d\n", &m, &n)。又或者把ch = getchar();换成上面那个我while循环 
	for(int i = 0; i < m; i ++)
	{
		scanf("%[^\n]%*c", str[i].value);	//接收一行 
	}
	
	for(int i = 0; i < n; i ++)
	{

		scanf("%s %*c%[^\"]", var[i].key, var[i].value);
		scanf("%*c"); // %[^\"] 不会接收后面的\"，不过\"还是在输入缓存中，在获取变量的值后需要把这个\"从输入缓存中去掉以免影响下一次 
	}
	
	for(int i = 0; i < m; i ++)	//循环输出m行模板 
	{
		int len = strlen(str[i].value);
		for(int j = 0; j < len; j ++)	//循环判断没行模板的每个字符 
		{
			if(str[i].value[j] == '{' && str[i].value[j+1] == '{')	//由于没有嵌套，所有直接判断即可 
			{
				char strtemp[100];
				j += 3;	//跳入模板变量区域
				int u = 0;
				while(str[i].value[j] != ' ')	//获取模板里的变量 
				{
					strtemp[u ++] = str[i].value[j];
					j ++;
				}
				for(int k = 0; k < n; k ++)	//查找对应的变量替代输出 
				{
					if(strcmp(strtemp, var[k].key) == 0)
					{
						printf("%s", var[k].value);
						break;
					}
				}
				j += 3;	//跳出模板变量区域 
			}
			else
			{
				printf("%c", str[i].value[j]);	//无需替换字符直接输出 
			}
		}
		printf("\n"); 
	}
	func();
	return 0;
}